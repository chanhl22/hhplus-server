# 선착순 쿠폰 발급 Redis 기반 설계 및 구현 보고서

## 1️⃣ 과제 개요
### 목표
선착순 쿠폰 발급 기능을 구현하되, **사용자 중복 발급을 방지하고**, **정해진 수량만 정확하게 발급**되도록 하는 것이 핵심 과제이다.

### 요구 사항
  - **중복 발급 제한**
    - 동일한 사용자가 하나의 쿠폰을 여러 번 발급받을 수 없도록 제한해야 한다.
  - **발급 갯수 제한**
    - 설정된 발급 수량을 초과하지 않도록 요청 수를 제한하며, 정확한 재고 관리를 통해 초과 발급을 원천적으로 방지해야 한다.
  - **동시성 제어**
    - 선착순 구조이므로 수많은 사용자 요청이 동시에 몰릴 수 있으며, 이 상황에서도 중복 없이 정확한 수량만 발급되도록 **동시성에 안전한 설계**가 필수이다.
  - **정확한 재고 관리**
    - 사용자 요청 수와 발급 수량 간의 불일치가 발생하지 않도록 **원자적 연산**을 통해 수량 체크 및 등록이 동시에 이루어져야 한다.
  - **Redis 활용 목적**
    - 빠른 응답과 병목 제거를 위해 **Redis를 메인으로 활용**한다.

---

## 2️⃣ 설계 고민 과정
기능 구현에 앞서 다음의 두 가지 설계 방식에 대해 장단점을 비교하고 최종 설계 방향을 결정했다.

### 🧪 방법 1: Redis에서 발급 검증 및 이력 관리, 스케줄러는 저장만 담당
해당 접근 방식은 Redis를 중심으로 선착순 발급의 모든 검증과 상태 관리를 수행하고, DB에는 단순 저장만 하는 구조였다.

#### ✅ 의도한 설계 방식
- Redis의 `Set`을 사용해 **중복 발급 여부를 즉시 확인**
- Redis 내부에 **발급 이력을 List로 저장**하여 사용자가 요청 즉시 쿠폰을 사용할 수 있도록 함
- 특히 쿠폰 발급 직후 DB에 반영되지 않더라도, **주문 API가 Redis 캐시에서 발급 여부를 판단**하면 실시간 처리가 가능하다고 판단
- 이로써 사용자 경험이 끊기지 않고, 빠른 응답성을 확보할 수 있을 것으로 기대

#### ❌ 방법 1의 문제점
1. 주문 API 수정 부담
   - 주문 API에서 **Redis 캐시를 직접 참조하도록 수정**해야 하는데, 이는 도메인 간 결합도를 높이며 전체 시스템 안정성을 해칠 수 있다고 판단했다.
   - 실시간 쿠폰 사용을 위해 레디스를 참조하는 로직은 데이터 정합성에 위험이 있다고 생각해 부적절하다고 판단했다.
2. **동시성 이슈 존재**
   - Redis는 기본적으로 **단일 명령은 원자성**을 보장하지만, **여러 단계의 쿠폰 검증 + 발급 이력 기록 로직은 하나로 묶이지 않으면 race condition**이 발생할 수 있다.
   - 이를 해결하기 위해 **Lua 스크립트를 사용해 복합 로직을 원자적으로 처리**해야 했고, 이는 개발 난이도 및 유지보수 관점에서 부담으로 작용했다.
3. **설계 철학의 충돌**
   - 발급 이력이 실제 DB가 아닌 Redis에 존재하는 동안 이를 "정상 발급된 쿠폰"으로 간주해야 한다는 점이 문제였다.
   - 쿠폰 발급은 비즈니스적으로 **정확하고 일관된 기록이 요구되는 도메인**인데, 캐시를 기준으로 판단하는 설계는 신뢰성을 떨어뜨릴 우려가 있었다.

#### 📌 결론
결과적으로, 방법 1은 **빠른 응답성과 실시간성** 측면에서 유리했지만, 아래의 문제점 등의 이유로 선택하지 않았다.
- 시스템 구조 복잡도 증가
- Redis 의존 설계
- 동시성 처리의 어려움(Lua 스크립트 의존)

### 🧪 방법 2: Redis에는 요청만 저장, 검증 및 발급은 스케줄러가 수행
이 접근 방식은 Redis를 단순히 **쿠폰 발급 요청 큐로만 사용하는 설계**로, 발급 검증과 DB 저장을 스케줄러가 전담하는 구조이다. 발급 시점은 사용자 요청이 아닌, 스케줄러가 데이터를 조회하고 처리하는 시점이다.

#### ✅ 의도한 설계 방식
- 사용자가 쿠폰 발급 요청을 하면 **Redis에 요청 정보만 저장**한다.
- Redis에 쌓인 요청들을 **스케줄러가 주기적으로 조회**해 중복 여부와 수량 제한을 검증한 후 **DB에 발급 내역을 반영**한다.
- 이렇게 하면 Redis에는 단순한 요청 저장만 하므로, 복잡한 Lua 스크립트 없이 구현 가능하다고 기대했다.

#### ❌ 방법 2의 문제점
1. **발급 수량 초과 가능성**
   - Redis에 단순히 요청만 저장하므로, 이론적으로 **발급 수량보다 더 많은 요청이 저장될 수 있다.**
   - 예를 들어 100개 한정 쿠폰인데 101명의 사용자가 동시에 요청하면, Redis에는 101건이 들어간다.
   - 이 경우 **스케줄러가 요청 순서를 고려하지 않으면 마지막 요청자에게도 쿠폰이 발급될 수 있는 문제**가 발생한다.
2. **순서 보장을 위해 결국 리스트(List)를 사용해야 함**
   - 발급 순서를 보장하려면 Redis의 `List` 구조를 사용해야 한다 (`LPUSH`, `RPOP` 등).
   - 하지만 `List`는 동시성 상황에서 **요청이 뒤엉킬 수 있고**, **중복 체크(Set)** 와 함께 사용할 경우 루아 스크립트를 사용해야만 **원자성 및 순서**를 보장할 수 있다.
   - 즉, **루아 스크립트를 쓰지 않기 위한 설계였으나, 결과적으로는 동일한 문제가 발생**하게 된다.
3. **사용자 경험 저하**
   - 사용자 입장에서는 **쿠폰 발급 요청을 했지만 실제로는 실패할 수 있는 구조**가 된다.
   - 요청 당시에는 발급된 줄 알고 넘어가지만, 배치가 돌면서 중복이거나 재고 초과로 실패 처리될 수 있기 때문에 **예측 불가능한 UX**가 된다.
   - 쿠폰 발급 후 바로 사용하는 시나리오에서는 더욱 문제가 된다. DB에 반영되기 전까지는 주문 API가 발급 여부를 확인할 수 없으므로, Redis를 직접 참조하게끔 API를 수정해야 하는 **1번 방식과 동일한 구조 변경 부담**이 발생한다.

#### 📌 결론
결과적으로 이 방식은 **루아 스크립트를 사용하지 않고 간단하게 구현**하려는 목적에서 시작했지만,  
순서를 지키면서 중복 발급을 방지하려면 **결국 루아 스크립트로 원자적 처리를 해야 하며,  
발급 실패 가능성으로 사용자 경험이 저하**되고,  
1번 방식과 마찬가지로 **주문 로직에 Redis를 활용하는 구조 변경이 필요**하다는 점에서 **채택하지 않았다.**

### 🧩 최종 구조 설계

1. **쿠폰 발급 요청 시**
   - 루아 스크립트를 사용해 Redis에서 **중복 체크(Set)**, **재고 확인**, **요청 등록(HASH: 상태 = `pending`)** 을 모두 원자적으로 처리.
   - 요청이 성공하면 사용자 ID를 Set에 등록하고 상태를 `pending`으로 설정.
2. **스케줄러 (3초마다 배치 실행)**
   - Redis에 저장된 `pending` 상태의 사용자 목록을 조회.
   - 상태를 `success`로 변경하고 DB에 실제 발급 내역 저장.
3. **사용자 Polling (발급 상태 확인 API)**
   - 사용자는 발급 요청 후 **polling API**를 주기적으로 호출.
   - Redis의 상태값(`pending`, `success`, `fail`)을 기반으로 **발급이 성공했는지 여부를 확인**함.

#### 🎯 기대 효과
- **동시성 문제 해결**:
  - 루아 스크립트를 통해 **중복 체크 + 재고 확인 + 요청 등록**을 한 번에 처리하여 race condition 제거.
- **정확한 재고 제어**:
  - Set에 최대 발급 수만큼만 사용자 ID가 들어가므로, Redis 상에서도 **정확한 발급 제한 수량을 보장**할 수 있음.
- **사용자 경험 개선**:
  - 사용자가 **발급된 줄 알았는데 실제로는 실패**하는 문제를 **polling 방식으로 보완**.
  - 완전한 실시간은 아니지만, **발급 상태를 직접 확인할 수 있는 API 제공**으로 불확실성 최소화.

#### 📌 결론
이 구조는 **루아 스크립트 기반 Redis 발급 검증 로직의 안정성**과 **Polling을 통한 사용자 경험 보완**이라는 두 가지 관점을 모두 만족시키는 현실적인 대안이었다.  
즉, **정확한 발급 수량 통제**, **동시성 제어**, **발급 직후 쿠폰 사용 가능성 확보**, **예측 가능한 사용자 경험 제공**이라는 네 가지 목표를 동시에 달성할 수 있는 구조로 최종 설계를 마무리했다.  

---

## 3️⃣ 시스템 아키텍처 설계
### ✅ 전체 쿠폰 발급 플로우
```text
Client
   │
   ▼
Redis Lua Script 실행
   ├─ 중복 발급 여부 확인 (Set)
   ├─ 재고 확인 (GET)
   ├─ 사용자 ID 등록 (Set)
   ├─ 쿠폰 상태 "pending" 저장 (Hash)
   └─ 쿠폰 ID를 발급 대기 목록에 등록 (Set)
   │
   ▼
[3초 간격 스케줄러 배치]
   ├─ Redis에서 "pending" 상태 사용자 조회
   ├─ 상태를 "success"로 변경
   └─ DB에 쿠폰 발급 이력 저장
   
   
Client
   │
   ▼
Polling API 호출
   ├─ Redis에서 사용자 쿠폰 상태 확인
   ├─ 상태가 "success" → 발급 완료 → 사용 가능
   └─ 상태가 "pending" → 일정 간격으로 재요청

```
* 즉시성 확보를 위해 Redis에서 Lua Script로 선요청 처리
* 신뢰성 확보를 위해 스케줄러에서 실제 DB 저장
* 사용자 경험 향상을 위해 상태를 Polling으로 확인 가능하게 구현
---

## 4️⃣ 상세 설계
### 1 발급 요청 처리
#### ⚙️ Redis Lua Script 기반 동시성 제어
Redis에서의 핵심 역할은 **쿠폰 요청의 중복 여부 및 재고 확인을 원자적으로 처리**하는 것이다.  
이를 위해 다음과 같은 Lua 스크립트를 사용했다.  
Lua는 Redis 명령어를 원자적으로 실행할 수 있도록 보장하므로, 여러 사용자의 동시 요청 상황에서도 데이터 정합성을 확보할 수 있다.  

#### 사용된 Lua 스크립트 로직 설명
```text
lua
복사편집
-- 입력값: userId (ARGV[1]), couponId (ARGV[2])
-- 키: 중복 요청 저장용 Set (KEYS[1]), 재고 키 (KEYS[2]), 상태 저장용 Hash (KEYS[3]), 활성 쿠폰 ID Set (KEYS[4])

-- 1. 이미 요청한 유저인지 확인 (중복 방지)
if redis.call("SISMEMBER", KEYS[1], userId) == 1 then
    return 0 -- 이미 요청한 유저
end

-- 2. 재고 확인
local stock = tonumber(redis.call("GET", KEYS[2]) or "-1")
if stock < 0 then
    return -2 -- 재고 정보 없음
end

-- 3. 현재 요청 수와 비교하여 재고 부족 여부 판단
local requestedCount = redis.call("SCARD", KEYS[1])
if (stock - requestedCount) <= 0 then
    return -1 -- 재고 부족
end

-- 4. 요청 등록
redis.call("SADD", KEYS[1], userId)
redis.call("HSET", KEYS[3], userId, "pending")

-- 5. 해당 쿠폰 ID를 활성 쿠폰 리스트에 추가 (후속 배치를 위해)
redis.call("SADD", KEYS[4], couponId)

return 1 -- 성공
```
- **중복 요청 방지**: `SISMEMBER` 명령어로 userId가 이미 요청한 적 있는지 확인
- **재고 동시성 처리**: `SCARD`를 통해 현재 요청 수를 비교하여 실시간 재고 체크
- **요청 상태 저장**: `HSET`으로 사용자 요청을 `"pending"` 상태로 저장
- **활성 쿠폰 ID 관리**: 배치 대상 쿠폰 ID를 별도 Set에 유지하여 반복 조회 최소화

이 Lua 스크립트를 통해 Redis 내부에서 모든 검증과 상태 처리가 **원자적**으로 수행되며, 이는 선착순 쿠폰 발급과 같이 민감한 동시 요청 처리에서 매우 중요한 역할을 한다.

### 2. 쿠폰 발급 배치 (3초 간격 스케줄러)
1. 발급 대기 쿠폰 목록(Set) 확인  
   * Redis에는 발급 요청 시 쿠폰 ID를 별도의 Set에 등록
   * 배치는 이 Set에 있는 쿠폰 ID 목록만 대상으로 동작 → 모든 쿠폰이 아니라, 실제로 발급 요청이 있었던 쿠폰만 처리

2. 각 쿠폰 ID에 대해 다음을 수행
   * 해당 쿠폰에 대해 Redis에 저장된 사용자 목록(Set)을 조회
   * 이 Set에는 사용자 ID가 저장되어 있고, 각 사용자별 상태는 Hash에 pending으로 들어 있음

3. pending 상태인 사용자만 선별 처리
   * 사용자 상태가 이미 success 또는 다른 상태이면 무시하고, pending만 대상으로 처리
   * 이 검증을 통해 중복 처리 및 무의미한 반복 작업을 방지

4. success 처리 및 DB 저장
   * 실제 DB에 쿠폰 발급 이력을 저장
   * Redis의 사용자 상태를 pending → success로 변경

### 3. Polling을 통한 발급 여부 확인
#### ✅ 기존 문제점
* 사용자는 발급 요청 후 응답만 보고 "성공했다고 착각"함  
* 실제로는 서버에서 스케줄러 처리 중 오류(예: DB 저장 실패)가 발생할 수 있음
* 이로 인해 사용자는 발급되지 않은 쿠폰을 받은 줄 알고 혼란이 생김  

#### 🔍 Polling 방식 도입 효과
* 실시간 처리처럼 느껴지도록 유도 (1~3초 내외 딜레이)  
* 사용자는 명확하게 발급 성공 여부를 확인한 후에만 쿠폰 사용 가능  
* PENDING → SUCCESS 또는 FAIL로 명확한 흐름을 제공  
* 예상치 못한 실패(DB 오류 등)에 대해 적절한 피드백 및 대응 가능  

---

## 5️⃣ 한계점 및 향후 고려사항

### 1. Lua Script 없는 구조로 개선
- 현재 구조는 동시성 문제 해결을 위해 Lua Script를 사용하고 있지만, 이는 작성과 유지보수가 어렵고 디버깅이 복잡하다는 단점이 있다.

### 2. 쿠폰 실시간 발급 적용
- 현재는 배치 스케줄러를 통해 쿠폰을 DB에 저장하고 있으나,
    - 향후에는 Kafka 또는 Redis Stream을 통해 **발급 요청 → 검증 → DB 저장까지 실시간 처리**가 가능하도록 개선할 수 있다.
- 이를 통해 **사용자가 발급 요청을 한 직후 바로 쿠폰을 사용할 수 있는 경험**을 제공할 수 있으며,
- 주문 API도 Redis가 아닌 DB 기준으로 동작하게 되어 **일관성 있는 데이터 흐름**을 만들 수 있다.

### 3. 모니터링 및 장애 대응 강화
- 현재 구조에서는 Redis나 스케줄러 장애 발생 시 처리 지연 가능성이 있다.
- 향후에는 **Prometheus + Grafana 기반 모니터링**, **스케줄러 재시도 로직 보완**, **Slack 알림 등 장애 대응 체계 강화**도 고려해야 한다.

---

## 6️⃣ 결론

이번 Redis 기반의 선착순 쿠폰 발급 기능 구현은 **대량 트래픽 환경에서의 안정적인 동시성 처리**와 **빠른 응답 제공**이라는 측면에서 의미 있는 경험이었다. 특히 Lua Script를 통한 원자성 보장과 스케줄러를 통한 DB 부하 분산 전략은 실무에서 충분히 활용 가능한 구조라고 판단된다. 다만 사용자 경험 측면에서 Polling을 어떻게 개선할 것인지가 다음 개선 과제가 될 것이다.