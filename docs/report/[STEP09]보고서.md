# 보고서: 동시성 이슈를 해결하기 위해 적합한 DB Lock 적용 및 AS-IS / TO-BE 비교

# 📌 **1. 문제 식별 (Issue Identification)**

시스템 내에서 쿠폰, 상품, 포인트 등의 자원을 차감하거나 충전하는 과정에서 **동시 요청**이 발생할 경우, 다음과 같은 문제가 발생할 수 있음.

- **이중 차감** 또는 **차감 누락**
- **재고 부족 상태에서의 거래 성공 처리**
- **정합성 오류**

### ✅ 1) 선착순 **쿠폰 차감 – 중복 차감 및 데이터 분실**

- **현상**
    - 발급 수량이 정해진 선착순 쿠폰을 여러 사용자가 동시에 요청.
- **문제점**
    - 이중 차감
        - 재고 1장 남은 쿠폰을 동시에 두 명이 요청한 경우, 둘 다 성공 처리되며 재고가 음수가 되는 현상 발생.
    - 데이터 유실
        - 총 100개로 설정된 쿠폰 발급을 동시에 요청했으나, 충돌로 인해 실제 DB에는 70건만 저장되고 나머지는 유실됨.

### ✅ 2) **상품 차감 – 초과 판매 및 재고 정합성 파괴**

- **현상**
    - 수량이 정해진 상품을 여러 사용자가 동시에 구매 요청.
- **문제점**
    - 초과 판매
        - 남은 재고 3개에 대해 5명의 사용자가 동시에 구매를 시도했을 경우, 모든 요청이 성공 처리되어 실제 재고보다 많은 수량이 판매됨.
    - 정합성 파괴
        - 판매 수량과 실제 재고 수량이 불일치하게 되어, 재고 마이너스 상태 발생 → 이후 주문 처리 불가 상황 유발.
        - 비즈니스 로직 상 재고 0 이하인 상태에서도 판매가 가능하게 되어 시스템 무결성 훼손.

### ✅ 3) **포인트 차감/충전 – 포인트 오차 발생**

- **현상**
    - 한 유저의 연속된 클릭으로 차감 또는 충전 요청을 동시에 요청.
- **문제**
    - 포인트 오차 발생
        - 두 번 충전했는데 충전 잔액이 누락되는 현상 발생.
        - 현 비즈니스 로직에서는 발생하지 않지만 포인트를 차감한 동시에 충전하는 요청이 들어와 처리 순서에 따라 예기치 않은 결과 발생 가능.

---

# 🔍 **2. 분석 (Analysis)**

| 항목 | 자원 특성 | 동시성 이슈 | AS-IS 처리 방식 | 문제점 |
| --- | --- | --- | --- | --- |
| **쿠폰 차감** | 선착순, 한정 수량 | 이중 차감, 발급 누락( 데이터 유실) | 단순 쿠폰 SELECT → UPDATE, 락 없음 | 동시에 여러 사용자가 접근하여 재고를 초과하거나 발급되지 않는 경우 |
| **상품 차감** | 한정 재고 | 초과 판매, 재고 정합성 오류 | 단순 재고 SELECT → UPDATE, 락 없음 | 동시에 재고 수량보다 많은 구매 요청이 발생하여 초과 판매됨 |
| **포인트 차감/충전** | 유저별 누적 포인트 | 충전 누락, 처리 순서에 따른 포인트 오차 | 단순 포인트 SELECT → UPDATE, 락 없음 | 충전 누락 및 동시에 차감 및 충전 요청 시 처리 순서에 따라 잔액이 엉켜버림 |

---

# 🛠 **3. 해결 방안 (Resolution)**

### ✅ 락 방식 장단점

- **낙관적 락 (Optimistic Lock)**
    - **Pros**
        - DB에 직접 락을 걸지 않기 때문에, 락 획득/해제에 따른 오버헤드가 없음. 시스템에 부하가 적음.
        - 대부분의 경우 락 없이 트랜잭션이 빠르게 처리되므로, 전체적인 처리 속도가 빠름.
        - 충돌이 많이 없는 상황에서 성능상 이점이 큼.
        - 데이터에 락을 걸지 않기 때문에, 트랜잭션 간 데드락(Deadlock)이 발생하지 않음.
    - **Cons**
        - 사용자가 많거나 동일 데이터를 자주 수정하는 환경에서는 충돌이 빈번해지고, 그만큼 rollback & retry 횟수도 증가함. 오히려 부하 유발 가능성 있음.
        - 충돌 발생 시 사용자에게 재시도 요청을 하거나, 로딩 시간이 길어지는 사용자의 경험에 문제가 발생할 수 있음.
- **비관적 락 (Pessimistic Lock)**
    - **Pros**
        - 데이터에 대해 **물리적인 락을 걸기 때문에**, 동시에 여러 트랜잭션이 값을 변경하는 일이 **원천적으로 차단됨.**
        - 재시도 로직 없이 한번에 처리되는 구조이므로, **낙관적 락보다 오히려 성능이 더 나은 경우도 있음.** 특히 트랜잭션 충돌이 빈번한 시스템에서는 낙관적 락보다 **안정적 처리 가능**.
        - 무조건 성공해야하는 케이스에 사용. 충돌이 발생하더라도 선점한 트랜잭션이 확실하게 작업을 완료할 수 있음.
    - **Cons**
        - 락 점유로 인한 데드락, 트랜잭션 대기 등 성능 저하 가능.
        - 락 획득/해제 비용이 발생. 데이터에 접근할 때마다 락을 획득하고 해제하는 작업이 추가되므로, 오버헤드가 생김.
        - 하나의 트랜잭션이 자원을 점유하는 동안 다른 트랜잭션은 대기해야 하므로, 전체 시스템의 동시 처리량이 급감.

### ✅ 락 선택 기준 체크리스트 (Optimistic vs Pessimistic)

| 질문 | 낙관적 락 적합 | 비관적 락 적합 |
| --- | --- | --- |
| **충돌이 자주 발생하는가?** | ❌ (재시도 많아짐) | ✅ (선점 처리 안전) |
| **데이터 정합성이 절대적으로 중요한가?** | ⚠️ (충돌 감지 후 복구) | ✅ (충돌 자체 방지) |
| **동시에 여러 사용자가 같은 자원을 갱신하는가?** | ❌ (충돌 잦음) | ✅ (락으로 보호) |
| **사용자가 실패 시 재시도하는 것이 허용되는가?** | ✅ | ❌ (실패 자체가 비즈니스 리스크) |
| **트랜잭션 데드락에 민감한가?** | ✅ (락 없음) | ❌ (데드락 발생 가능) |

### ✅ 나만의 **락 전략 선택 기준**

| 기준 | 선택 전략 | 설명 |
| --- | --- | --- |
| 충돌이 많이 발생하며 **성공이 보장되어야 하는 상황.**  | 비관적 락 (Pessimistic Lock) | 미리 락을 걸어 다른 트랜잭션 접근 차단. 정합성이 절대적으로 중요하며, 동시성 경쟁이 심한 상황에 적합. |
| 충돌이 덜 발생하며 실패해도 재시도를 사용자한테 다시 요청할 수 있는 상황 | 낙관적 락 (Optimistic Lock) | 커밋 시점에 체크하고 실패 시 재시도나 실패 메시지 반환. 충돌이 드문 경우 사용. |

### ✅ 기능별 해결 방안

기능별로 적절한 DB Lock 전략을 적용하여 동시성 문제 해결

| 기능 | TO-BE | 적용 방식 | 이유 |
| --- | --- | --- | --- |
| 쿠폰 차감 | **비관적 락 (Pessimistic Lock)** | SELECT ... FOR UPDATE | 재고가 매우 적고 경쟁이 심하므로 즉시 락을 걸어야 정합성 유지 가능 |
| 상품 차감 | **낙관적 락 (Optimistic Lock)** | 버전 필드 사용 (version 컬럼 기반) | 상품의 종류가 많아 대부분의 경우 충돌이 없고, 성능을 고려하여 낙관적으로 처리. 재시도 로직을 추가할 수 있음. |
| 포인트 차감/충전 | **비관적 락 (Pessimistic Lock)** | SELECT ... FOR UPDATE | 사용자별 자원으로, 실시간 정합성이 매우 중요하고 동시 변경이 잦음 |

### ✅ 트랜잭션 흐름도 (기능별)

#### 1. 쿠폰 차감 (비관적 락 - Pessimistic Lock)

```sql
[사용자 요청 수신]
        ↓
[DB 트랜잭션 시작]
        ↓
SELECT * FROM coupon WHERE coupon_id = ? FOR UPDATE;
        ↓
재고 수량 확인 (count > 0)
        ↓
UPDATE coupon SET remainingQuantity = remainingQuantity - 1 WHERE coupon_id = ?
        ↓
[트랜잭션 커밋]
        ↓
[응답 반환]

```

#### 2. 상품 차감 (낙관적 락 - Optimistic Lock)

```sql
[사용자 요청 수신]
        ↓
[DB 트랜잭션 시작]
        ↓
[주문/결제 시작]
        ↓
SELECT * FROM product WHERE product_id = ?
        ↓
재고 수량 확인 및 version 값 조회
        ↓
UPDATE stock 
SET quantity = quantity - ?, version = version + 1 
WHERE stock_id = ? AND version = ?
        ↓
[성공 → 트랜잭션 커밋]
[실패(영향 row=0) → 충돌 감지 → 재시도 또는 실패 응답]

```

#### 3. 포인트 차감/충전 (비관적 락 - 사용자 단위)

```sql
[사용자 요청 수신]
        ↓
[DB 트랜잭션 시작]
        ↓
SELECT * FROM point WHERE point_id = ? FOR UPDATE;
        ↓
현재 포인트 확인 (충분한지 검증)
        ↓
UPDATE point SET amount = amount ± ? WHERE user_id = ?
        ↓
[트랜잭션 커밋]
        ↓
[응답 반환]
```

### ✅ **결론 및 기대 효과**

- **적절한 락 전략 적용을 통해 데이터 정합성 보장**
- **사용자 간 경쟁 상황에서 예외 발생률 감소**
- **성능과 안정성의 균형 유지**

---

# 📘 **4. 동시성 제어를 위한 기타 대안 및 고려사항**

비관적 락과 낙관적 락은 대표적인 DB 레벨 동시성 제어 기법이지만, 시스템 성능과 요구 사항에 따라 다음과 같은 다양한 대안을 고려할 수 있음.

### ✅ 1) **분산 락 (Distributed Lock)**

- **개념**:
    - DB 대신 Redis 등의 외부 시스템을 이용해 락을 제어
- **활용 시점**:
    - 여러 서버 인스턴스 간 동일 자원에 대한 접근을 제어해야 할 때
    - 예: 분산 환경에서 특정 쿠폰 코드 발급을 1명만 성공시키는 경우
- **장점**:
    - DB 부하 감소
    - 분산 환경에서도 동시성 보장 가능
- **단점 및 고려사항**:
    - 락 해제 누락 시 데드락 가능
    - 락 유지 시간(Time-to-Live) 관리 필요
    - 구현 복잡도 및 네트워크 신뢰성 의존

### ✅ 2) **큐 기반 처리 (Message Queue / Job Queue)**

- **개념**
    - 사용자 요청을 큐에 적재하고, 백엔드에서 순차적으로 처리
- **활용 시점**
    - 자원 차감 요청이 대량으로 들어올 가능성이 있을 때 (ex. 플래시 세일, 대규모 이벤트)
- **장점**
    - 처리 순서 보장
    - 처리량을 제한하여 시스템 안정성 확보
- **단점 및 고려사항**
    - 실시간성이 다소 떨어질 수 있음
    - 큐 장애 또는 적체 시 사용자 응답 지연
    - 사용자에게 비동기 응답 설계 필요

### ✅ 3) **CAS (Compare And Swap) 기반 처리**

- **개념**
    - 특정 필드(예: 버전, 잔고 등)의 현재 값을 비교한 뒤 일치할 경우만 업데이트
    - 낙관적 락과 유사하지만 DB보다는 애플리케이션 또는 캐시 레벨에서 수행
- **활용 시점**
    - 고성능 요구 / DB 대신 메모리 기반에서 일관성 제어가 필요한 경우
- **장점**
    - 락 점유 없음
    - 빠른 처리 가능
- **단점 및 고려사항**
    - 충돌 시 로직이 복잡해짐 (retry loop)
    - DB와의 최종 정합성을 별도로 맞춰야 함

### ✅ 4) **ID 기반 제어 (Token / UUID / 사용자 기반 Key)**

- **개념**
    - 동일 요청을 식별 가능한 ID로 구분하고, 중복 요청은 무시
- **활용 시점**
    - 동일 사용자의 중복 클릭 방지, 요청 중복 차단 (프론트/백 모두 적용 가능)
- **장점**
    - 단순 구현 가능
    - 클라이언트 단에서 일부 제어 가능
- **단점 및 고려사항**
    - 완전한 동시성 제어는 아님
    - 트랜잭션 경합 시 보조적 수단으로만 활용

### ✅ 5) **타임 윈도우 / 쓰로틀링 (Rate Limiting)**

- **개념**
    - 일정 시간 내 요청 횟수를 제한하여 서버 부하 및 중복 요청 방지
- **활용 시점**
    - 사용자의 과도한 요청으로 인한 race condition을 줄이고 싶을 때
- **장점**
    - 성능 보호
    - 비정상 요청 차단 가능
- **단점 및 고려사항**
    - 시간 내 정상 요청도 제한될 수 있음
    - 실시간 응답 요구 시 부적합