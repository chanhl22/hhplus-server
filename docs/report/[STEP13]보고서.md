# Redis 기반 인기 상품 랭킹 시스템 설계 및 구현 보고서

## 1️⃣ 과제 개요
### 🔸 목표
* 가장 많이 주문된 상품을 기준으로 일간 및 주간 랭킹을 제공하는 기능을 Redis를 활용하여 설계하고 구현한다.  
* Redis를 활용하여 **실시간에 가까운 빠른 조회 성능**과 **효율적인 데이터 만료 및 저장 관리**를 달성한다.  
* 사용자 또는 관리자에게 **일간(Daily), 주간(Weekly) 단위의 인기 상품 랭킹**을 제공한다.  

### 🔸 요구사항
- **일간(daily)**, **주간(weekly)** 랭킹을 각각 Redis에 저장
- 주문 발생 시, 해당 상품의 주문 수량을 기반으로 랭킹을 업데이트
- 클라이언트는 Redis에서 인기 상품 랭킹을 조회

---

## 2️⃣ 설계
### 🔸 Redis 자료구조
- Redis **Sorted Set (ZSet)** 사용
  - `key`: 위의 날짜 기반 키
  - `member`: 상품 ID
  - `score`: 누적 주문 수량

Redis의 Sorted Set은 각 요소에 score(점수)를 부여하고, 이를 기준으로 자동 정렬되는 자료구조다.  
현 요구사항에서 상품 ID를 요소로, 주문 수량을 score로 활용하여 자연스럽게 높은 주문 수량을 가진 상품이 상위에 위치하도록 구성하였다.  

또한 Sorted Set은 다음과 같은 장점을 제공한다.
 - **빠른 순위 조회 (`ZREVRANGE`)**
   - score 기준으로 정렬된 결과를 즉시 상/하위 랭킹 형태로 제공할 수 있다.
 - **동시에 여러 score 업데이트 가능 (`ZINCRBY`)**
   - 주문 발생 시 수량만큼 score를 증가시키는 방식으로 실시간 누적 처리가 가능하다.
 - **정렬과 데이터 보관을 동시에 해결**
   - 별도의 정렬 처리 없이 저장된 상태 그대로 빠르게 랭킹 제공 가능
 - **범위 기반 조회 지원 (`ZRANGEBYSCORE`)**
   - 특정 기간, score 조건 등에 따라 필터링된 랭킹도 손쉽게 구현 가능

이러한 특성 덕분에 Sorted Set은 **실시간 랭킹**, **누적 집계**, **랭킹 조회 성능 최적화** 측면에서 매우 적합한 선택이었으며, 핵심 요구사항을 만족시키는 데 중요한 역할을 하였다.

### 🔸 Redis 키 구조
* 랭킹 저장
  * 일간 랭킹: product:ranking:daily:yyyyMMdd 형식의 Redis 키에 저장
  * 주간 랭킹: product:ranking:weekly:yyyy-'W'ww 형식의 Redis 키에 저장
  * 예시
    ```text
    product:ranking:daily:yyyyMMdd     # 예시: product:ranking:daily:20250515
    product:ranking:weekly:yyyy-'W'ww  # 예시: product:ranking:weekly:2025-W20
    ```
  
#### ❓ 이러한 키 구조를 선택한 이유?
주문 발생 시점에 상품 주문 수량을 기반으로 랭킹을 증가시키기 위함이다.  
사용자가 상품을 주문할 때마다 해당 상품의 주문 수량을 기준으로 일간 및 주간 랭킹의 점수(score)를 동시에 증가시켜야 하기 때문에, 날짜 혹은 주차별로 고유하게 구분된 키가 필요하다.   
일간 랭킹은 하루 단위로 집계되며, 특정 날짜의 주문 데이터를 기준으로 구성된다.  
이 키는 정확히 해당 날짜를 기준으로 한 랭킹을 표현한다.

주간 랭킹은 현재 날짜가 포함된 주(월요일~일요일) 기준으로 집계된다.  
예를 들어, 오늘이 수요일(2025년 5월 14일)이라면, 해당 주간 랭킹은 2025년 5월 12일(월요일)부터 5월 18일(일요일)까지의 누적 주문 데이터를 포함한다.   
이 구조는 ISO 주차 기준(yyyy-'W'ww)을 따라 일관되고 범용적인 주간 단위를 표현할 수 있도록 설계했다.

이처럼 명확한 키 네이밍 규칙을 통해 데이터의 분리성과 관리 용이성을 확보하고, 향후 랭킹 데이터를 주기적으로 만료 및 갱신하는 데에도 유리한 구조를 마련하였다.

### 🔸 수명 주기 관리
* 일간 랭킹 데이터는 2일간 유지
* 주간 랭킹 데이터는 8일간 유지
* Redis TTL(Time-To-Live)을 통해 자동 만료 처리

#### ❓ 조금 더 넉넉한 보관 기간을 설정한 이유?
조회 지연 또는 처리 지연에 대비한 안전장치다.  
데이터 생성 및 반영이 정확히 자정 또는 주 시작 시점에 일어나지 않을 수 있기 때문에, 하루 또는 일주일 단위로 정확히 맞춰 삭제할 경우 랭킹 갱신 작업이나 조회 요청과 겹쳐 오류가 발생할 가능성이 있다.  
예를 들어, 자정 직전의 주문이 Redis에 늦게 반영되는 경우, 이미 만료되어버린 랭킹 키로 인해 집계 누락이 발생할 수 있다.  
하루 더 유지함으로써 시스템 간 반영 시점의 오차를 흡수할 수 있다.  

### 🔸 시스템 흐름
```text
[주문 발생]
      ↓
[DB 트랜잭션 커밋 완료]
      ↓
[Redis ZSet 업데이트]
   ├─ 일간 랭킹 (product:ranking:daily:yyyyMMdd)
   └─ 주간 랭킹 (product:ranking:weekly:yyyy-'W'ww)
```
- 트랜잭션 완료 이후에 Redis에 반영하여 일관성 보장
- 주문 수량이 많을수록 높은 score → 높은 랭킹

---
## 3️⃣ 회고
### ✅ 빠르고 안정적인 랭킹 조회
Redis의 Sorted Set 구조를 활용함으로써, 인기 상품 랭킹을 실시간에 가깝게 빠르게 조회할 수 있었고, 이는 사용자 경험 측면에서 긍정적인 효과를 가져왔다. 특히 조회 시점에 별도의 복잡한 연산 없이 ZREVRANGE 명령어만으로 고속 응답이 가능하였다.

### ✅ 효율적인 키 설계 및 관리 구조
날짜 및 주차를 기준으로 Redis 키를 분리함으로써, 데이터의 수명을 명확히 관리하고 유지보수에 용이한 구조를 만들 수 있었다. 이는 불필요한 데이터 축적을 막고, TTL 만료 정책과 결합하여 메모리 관리 효율도 향상시켰다.

### ✅ DB 트랜잭션 이후 Redis 업데이트 처리
Redis 랭킹 갱신을 DB 트랜잭션 이후 후처리로 처리함으로써, 데이터의 정합성을 유지할 수 있었다. 트랜잭션이 실패한 경우에도 Redis 랭킹에 잘못된 데이터가 반영되지 않도록 설계한 부분은 안정성을 높이는 데 기여하였다.

---
## 4️⃣ 아쉬운 점
### ❗ Redis 단일 저장소 의존으로 인한 복구 취약성
현재 랭킹 데이터는 Redis에만 저장되며, 별도의 영속화 또는 백업 장치가 없다. Redis 장애나 키 TTL 만료로 인해 데이터가 유실될 경우, 이를 복구할 방법이 없는 점은 중요한 리스크 요소이다.

### ❗ 주간 기준의 사용자 혼동 가능성
주간 키는 ISO 주차 기준(yyyy-'W'ww)을 따르고 있어, 내부적으로는 일관성 있지만 일반 사용자나 클라이언트 개발자 입장에서 직관적이지 않을 수 있다. 예를 들어, 어떤 날짜가 어느 주차에 포함되는지 혼동이 발생할 수 있다.  
개발자 문서 및 클라이언트와의 기준 날짜 명세를 공유하고 사전 협의 강화가 필요하다.  

---
## 5️⃣ 결론
Redis를 기반으로 한 인기 상품 랭킹 시스템의 설계 및 구현을 통해, 단순하면서도 효과적인 구조로 실시간성과 성능을 동시에 확보할 수 있음을 입증하였다.  
특히, Sorted Set 자료구조의 정렬 기능과 TTL 정책을 활용해 랭킹 조회 및 관리가 매우 효율적으로 이루어졌으며, 키 구조와 업데이트 타이밍에 대한 세밀한 고민을 통해 정합성과 성능의 균형을 잡을 수 있었다.  
물론 Redis 단독 사용에 따른 복구 리스크, 실시간 반영의 한계, 사용자 기준의 주차 혼동과 같은 보완 요소도 확인할 수 있었으며, 이러한 한계는 이벤트 기반 처리 및 백업 설계 강화, 명확한 클라이언트 기준 공유 등을 통해 개선할 수 있는 여지가 충분함을 알게 되었다.  